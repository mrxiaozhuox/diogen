---
title: DoreaDB 设计文档
date: 2021-12-23 00:12:51
tags: [Dorea]
category: Rust
---

> 近期在 Dorea 的开发过程中拥有一些独立的思考和设计方案，记录在此。（持续更新）

## 索引淘汰机制

`DoreaDB` 需要一套较为健全的淘汰机制以达到顺畅的使用效果。

我对于 `Bitcask` 的部分设计进行了更改，它不会一次将索引加载到内存中，而是分库加载：

- 系统启动：通过配置中的预加载列表来获取库（适用于数据量较大的库）
- 实时加载：在运行过程中被加载时，则会立刻进行索引加载。
- 预先加载：通过 `db preload` 发起预加载，它不会阻塞请求，而是开启线程去加载库。

数据库卸载的情况：

- 加载新库：当加载库时，如果当前 `Index` 空间不够，则自动会卸载 `权重` 最低的库。
- 数据写入：当写入时发现 `Index` 空间不够，也会自动卸载 `权重` 最低的库。
- 手动卸载：通过 `db unload` 命令手动卸载库索引。（开发中）

### 权重控制

我目前正在构思关于权重的设计方案（即为卸载库时的衡量标准）

首先需要明确的是卸载库的目的：将当前不常用的索引空间交给其他库去分配！

#### 权重计算

- 写入数据 `+ 2`
- 删除数据 `+ 1`
- 清空数据 `+ 10`

#### 最终权重

如下为一个已经被加载到内存的索引数据集

```
已用空间 / 最大空间：402 / 512

----------------------
[@库名称]  : 索引数  权重
----------------------

[@default]: 100    130
[@system] : 82     90
[@users]  : 128    160
[@config] : 92     100

```

有一个新库 `@groups` 要加入数据集，它拥有 120 条数据，而剩余空间已经不支持它的载入。

在默认情况下（无其他因素干涉的情况下）`@config` 库会被优先卸载。

```
单库最大值 = (最大空间 / 4)
```
```
最终权 =（权重 * (单库最大值 / 索引数)）
```

最终权不单要考虑单纯权重，还要考虑数据索引量（卸载更大的库可以腾出更多空间）

> 本套权重算法将作为 V0.3.1 的最终定版，如有任何建议欢迎提交 PR 👏